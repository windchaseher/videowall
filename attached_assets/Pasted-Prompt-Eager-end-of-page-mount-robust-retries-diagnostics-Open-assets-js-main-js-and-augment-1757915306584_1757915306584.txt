Prompt — Eager end-of-page mount + robust retries + diagnostics

Open /assets/js/main.js and augment the lazy-embed block as follows (leave URL builder, watermark, audio, parallax, and existing mobile/desktop tuning unchanged):

1) Near the top of the lazy-embed section, add retry tracking:
const retryCount = new WeakMap(); // frame -> number

2) Update mountIframe(frame) to support retries:
function mountIframe(frame) {
  if (!frame || frame.dataset.mounted === '1') return;
  const src = frame.dataset.embed;
  if (!src) return;

  // Prevent duplicate queueing
  if (frame.dataset.queued === '1') return;

  if (inFlight >= maxConcurrentLoads) {
    frame.dataset.queued = '1';
    queue.push(frame);
    return;
  }
  frame.dataset.queued = '0';
  inFlight++;

  const iframe = document.createElement('iframe');
  iframe.src = src;
  iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
  iframe.setAttribute('loading', 'lazy');
  Object.assign(iframe.style, { border:'0', position:'absolute', inset:'0', width:'100%', height:'100%' });

  frame.style.position = 'relative';
  frame.appendChild(iframe);
  frame.dataset.mounted = '1';

  let settled = false;
  const settle = () => {
    if (settled) return;
    settled = true;
    inFlight = Math.max(0, inFlight - 1);
    const next = queue.shift();
    if (next) mountIframe(next);
  };

  // Retry if load doesn't fire in time
  const maxRetries = 2;
  const t = setTimeout(() => {
    if (settled) return;
    const n = (retryCount.get(frame) || 0);
    if (n < maxRetries) {
      // Tear down and retry with small delay
      try { iframe.remove(); } catch {}
      frame.dataset.mounted = '0';
      retryCount.set(frame, n + 1);
      inFlight = Math.max(0, inFlight - 1);
      setTimeout(() => mountIframe(frame), 400 + n * 400);
    } else {
      // Give up and settle so queue continues
      settle();
    }
  }, 8000);

  iframe.addEventListener('load', () => { clearTimeout(t); settle(); }, { once: true });
}

3) Keep your existing IntersectionObserver, but do NOT unobserve frames on intersect; we want multiple chances.

4) Add an “end-of-page eager mount” that triggers when close to the bottom and also when only a few remain:
function eagerMountTail() {
  const doc = document.documentElement;
  const distanceToBottom = (doc.scrollHeight - doc.scrollTop - window.innerHeight);
  const remaining = frames.filter(f => f.dataset.mounted !== '1');
  if (remaining.length && (remaining.length <= 4 || distanceToBottom < 2000)) {
    remaining.forEach(f => mountIframe(f));
  }
}
window.addEventListener('scroll', eagerMountTail, { passive: true });
window.addEventListener('load', eagerMountTail);
window.addEventListener('resize', eagerMountTail);

5) (Desktop only) If you previously had recycling, keep it; but ensure you NEVER unmount a frame that has a pending retry (retryCount has a value) or that is within 4000px of the viewport:
function canRecycle(frame) {
  const hasRetry = retryCount.get(frame) > 0;
  if (hasRetry) return false;
  const r = frame.getBoundingClientRect();
  const far = (r.top > window.innerHeight + 4000) || (r.bottom < -4000);
  return far;
}
// Use canRecycle() wherever you decide to unmount on desktop.

6) Add a tiny diagnostic helper (optional) so I can see what’s left unmounted:
window.reportVimeoMounts = () => {
  const unmounted = frames.filter(f => f.dataset.mounted !== '1').length;
  const queued = frames.filter(f => f.dataset.queued === '1').length;
  return { total: frames.length, unmounted, queued };
};

After changes, test on the external preview (desktop and iPhone). When you scroll near the bottom, the last clips should appear reliably. In DevTools console (or Safari’s Web Inspector), run:
reportVimeoMounts()

Reply only with:
"STEP DONE — tail eager-mount + retries added"
and include the { total, unmounted, queued } object from the console at the very bottom of the page.
