Prompt — Staggered eager load (burst + timed batches, no scroll required)
Open /assets/js/main.js and replace ONLY the lazy-embed section with this staggered eager loader.
Do NOT change: Vimeo URL builder, watermark, audio, parallax, overlap clamps.

1) Ensure this flag is near the top (after 'use strict'):
const isSmall = window.matchMedia('(max-width: 768px)').matches;

2) After the render loop creates all .frame elements (each with frame.dataset.embed set),
insert this block:

// ---- STAGGERED EAGER LOAD (burst + timed batches) ----
const frames = Array.from(document.querySelectorAll('.frame'));

// Tunables
const initialBurstCount   = isSmall ? 6 : 8;  // load these immediately
const batchSize           = isSmall ? 3 : 4;  // then load this many per tick
const tickMs              = 700;              // time between batches (ms)
const maxConcurrentLoads  = isSmall ? 3 : 10; // cap simultaneous iframes
const loadTimeoutMs       = 7000;             // consider a load "settled" after this

let inFlight = 0;
let nextIndex = initialBurstCount; // after the burst, continue here
let batchTimer = null;

// Mount one frame if allowed by concurrency
function mountIframe(frame) {
  if (!frame || frame.dataset.mounted === '1') return;
  const src = frame.dataset.embed;
  if (!src) return;

  if (inFlight >= maxConcurrentLoads) return; // caller will retry next tick

  inFlight++;

  const iframe = document.createElement('iframe');
  iframe.src = src;
  iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
  iframe.setAttribute('loading', 'lazy');
  Object.assign(iframe.style, {
    border:'0', position:'absolute', inset:'0', width:'100%', height:'100%'
  });

  frame.style.position = 'relative';
  frame.appendChild(iframe);
  frame.dataset.mounted = '1';

  let settled = false;
  const settle = () => {
    if (settled) return;
    settled = true;
    inFlight = Math.max(0, inFlight - 1);
  };

  const t = setTimeout(settle, loadTimeoutMs);
  iframe.addEventListener('load', () => { clearTimeout(t); settle(); }, { once: true });
}

// Initial burst (top-of-page feels instant)
frames.slice(0, initialBurstCount).forEach(f => mountIframe(f));

// Timed batches keep loading even without scrolling
function loadNextBatch() {
  // If everything is mounted, stop.
  if (nextIndex >= frames.length) {
    if (batchTimer) { clearInterval(batchTimer); batchTimer = null; }
    return;
  }

  let mountedThisTick = 0;
  // Try to mount up to batchSize frames this tick, respecting concurrency
  while (mountedThisTick < batchSize && nextIndex < frames.length) {
    const f = frames[nextIndex];
    const beforeInFlight = inFlight;
    mountIframe(f);
    // Only count it if we actually started it (inFlight increased)
    if (inFlight > beforeInFlight) {
      mountedThisTick++;
      nextIndex++;
    } else {
      // Concurrency full; break and let next tick try again
      break;
    }
  }
}

// Start the interval; also warm on idle to feel snappier
if (!batchTimer) batchTimer = setInterval(loadNextBatch, tickMs);
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => loadNextBatch(), { timeout: tickMs });
}

// Last-resort safety: after ~12s, force-mount anything left (ignores concurrency)
setTimeout(() => {
  for (let i = 0; i < frames.length; i++) {
    if (frames[i].dataset.mounted !== '1') {
      // Try with cap; if still blocked, attach directly
      const before = inFlight;
      mountIframe(frames[i]);
      if (inFlight === before) {
        const iframe = document.createElement('iframe');
        iframe.src = frames[i].dataset.embed;
        iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
        iframe.setAttribute('loading', 'lazy');
        Object.assign(iframe.style, {
          border:'0', position:'absolute', inset:'0', width:'100%', height:'100%'
        });
        frames[i].style.position = 'relative';
        frames[i].appendChild(iframe);
        frames[i].dataset.mounted = '1';
      }
    }
  }
}, 12000);

// Optional: simple diagnostic in console
window.reportVimeoMounts = () => {
  const total = frames.length;
  const mounted = frames.filter(f => f.dataset.mounted === '1').length;
  return { total, mounted, inFlight };
};

3) Save and run the external preview.

Verify on desktop and phone:
- First 8 (desktop) / 6 (mobile) videos appear quickly.
- Remaining clips keep appearing every ~0.7s even if you don’t scroll.
- No permanent blanks; scrolling feels smooth.
- Parallax/overlap unchanged; watermark and click-to-start audio unchanged.

Reply only with:
"STEP DONE — staggered eager load applied and verified"