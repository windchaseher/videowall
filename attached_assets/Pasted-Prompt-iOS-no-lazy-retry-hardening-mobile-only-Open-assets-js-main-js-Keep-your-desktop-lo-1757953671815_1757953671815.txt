Prompt — iOS “no-lazy + retry” hardening (mobile only)
Open /assets/js/main.js. Keep your desktop loader and everything else unchanged (Vimeo URL builder, parallax, overlap, watermark, audio).

We will only replace the MOBILE loader with a stricter version that (a) never sets loading="lazy", (b) loads strictly one-by-one with retries, and (c) does an aggressive final sweep.

1) Ensure the device flag exists near the top:
const isSmall = window.matchMedia('(max-width: 768px)').matches;

2) Replace your current MOBILE loader function with this:

async function mobileSequentialLoadStrictNoLazy() {
  const frames = Array.from(document.querySelectorAll('.frame'));
  const eagerCount = Math.min(2, frames.length);  // small eager burst so the page shows life
  const loadTimeoutMs = 9500;                     // give iOS extra time
  const interMountDelayMs = 340;                  // spacing between mounts
  const maxRetries = 2;                           // retry per frame if stuck

  // Helper to mount one iframe WITHOUT loading="lazy"
  function mountEager(frame) {
    if (!frame || frame.dataset.mounted === '1') return false;
    const iframe = document.createElement('iframe');
    iframe.src = frame.dataset.embed;
    iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
    // IMPORTANT: no loading="lazy" on mobile
    Object.assign(iframe.style, { border:'0', position:'absolute', inset:'0', width:'100%', height:'100%' });
    frame.style.position = 'relative';
    frame.appendChild(iframe);
    frame.dataset.mounted = '1';
    return iframe;
  }

  // Eager burst (2 clips) without lazy hint
  for (let i = 0; i < eagerCount; i++) {
    mountEager(frames[i]);
    await new Promise(r => setTimeout(r, 220));
  }

  // Strictly one-by-one with retries; no lazy hint at all on mobile
  for (let i = eagerCount; i < frames.length; i++) {
    const f = frames[i];
    if (!f || f.dataset.mounted === '1') continue;

    let tries = 0;
    let done = false;
    while (!done && tries <= maxRetries) {
      tries++;
      // (Re)mount
      // If an old iframe exists, remove it first
      const old = f.querySelector('iframe');
      if (old) try { old.remove(); } catch {}
      f.dataset.mounted = '0';
      const ifr = mountEager(f);

      await new Promise((resolve) => {
        let settled = false;
        const t = setTimeout(() => { if (!settled) { settled = true; resolve(false); } }, loadTimeoutMs);
        if (ifr) {
          ifr.addEventListener('load', () => {
            if (!settled) { clearTimeout(t); settled = true; }
            resolve(true);
          }, { once: true });
        } else {
          clearTimeout(t); resolve(false);
        }
      }).then(ok => { done = ok; });

      // small spacing before next attempt or next frame
      await new Promise(r => setTimeout(r, interMountDelayMs + (tries * 60)));
    }
  }

  // Aggressive final sweep after 12s: eagerly attach to any frame that still missed
  setTimeout(() => {
    const left = Array.from(document.querySelectorAll('.frame')).filter(fr => fr.dataset.mounted !== '1');
    left.forEach(fr => {
      const prev = fr.querySelector('iframe');
      if (prev) try { prev.remove(); } catch {}
      const el = document.createElement('iframe');
      el.src = fr.dataset.embed;
      el.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
      Object.assign(el.style, { border:'0', position:'absolute', inset:'0', width:'100%', height:'100%' });
      fr.style.position = 'relative';
      fr.appendChild(el);
      fr.dataset.mounted = '1';
    });
  }, 12000);
}

3) Ensure the loader selection uses this stricter function:
if (isSmall) {
  mobileSequentialLoadStrictNoLazy();
} else {
  // keep your existing desktop loader call here, unchanged
  desktopHeartbeatLoad();
}

Save and run the EXTERNAL preview on an iPhone/Android device (full tab).

Reply only with:
"STEP DONE — iOS no-lazy + retry hardening applied and verified"