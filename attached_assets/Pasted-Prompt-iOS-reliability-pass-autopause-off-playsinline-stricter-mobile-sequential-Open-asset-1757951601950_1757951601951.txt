Prompt — iOS reliability pass (autopause off + playsinline + stricter mobile sequential)
Open /assets/js/main.js. Make the following targeted edits. Do NOT change parallax, overlap clamps, watermark, or audio logic.

1) Ensure the screen-size flag exists:
const isSmall = window.matchMedia('(max-width: 768px)').matches;

2) In your Vimeo URL builder (buildVimeoUrl), make sure we set these params:
- autoplay=1
- muted=1
- loop=1
- background=1
- autopause=0
- playsinline=1

Use this exact function body:

function buildVimeoUrl(base) {
  try {
    const url = new URL(base);
    const p = url.searchParams;
    p.set('autoplay','1');
    p.set('muted','1');
    p.set('loop','1');
    p.set('background','1');
    p.set('autopause','0');   // <-- important for many players at once
    p.set('playsinline','1'); // <-- iOS inline
    url.search = p.toString();
    return url.toString();
  } catch {
    const sep = base.includes('?') ? '&' : '?';
    return base + sep + 'autoplay=1&muted=1&loop=1&background=1&autopause=0&playsinline=1';
  }
}

3) Keep your current DESKTOP loader exactly as-is (your “desktop heartbeat” or staggered eager).
   We will ONLY replace the MOBILE loader to be strictly sequential and a touch slower for stability.

Find where you branch on isSmall and replace the MOBILE branch with this:

async function mobileSequentialLoadStrict() {
  const frames = Array.from(document.querySelectorAll('.frame'));

  // Mount a tiny eager burst WITHOUT lazy hint so we see something immediately
  const eagerCount = Math.min(2, frames.length);
  for (let i = 0; i < eagerCount; i++) {
    // build src now (ensure URL builder is used upstream when setting frame.dataset.embed)
    const f = frames[i];
    if (f.dataset.mounted === '1') continue;
    const iframe = document.createElement('iframe');
    iframe.src = f.dataset.embed;
    iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
    // EAGER: don't set loading="lazy" for first two on mobile
    Object.assign(iframe.style, { border:'0', position:'absolute', inset:'0', width:'100%', height:'100%' });
    f.style.position = 'relative';
    f.appendChild(iframe);
    f.dataset.mounted = '1';
    // brief spacing
    await new Promise(r => setTimeout(r, 250));
  }

  // Then strictly one-by-one with a comfortable delay between attempts
  const loadTimeoutMs = 9000;       // slightly longer for iOS networks
  const interMountDelayMs = 320;    // spacing to avoid handshake spikes

  for (let i = eagerCount; i < frames.length; i++) {
    const f = frames[i];
    if (f.dataset.mounted === '1') continue;

    // Create with lazy hint for the rest
    const iframe = document.createElement('iframe');
    iframe.src = f.dataset.embed;
    iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
    iframe.setAttribute('loading', 'lazy');
    Object.assign(iframe.style, { border:'0', position:'absolute', inset:'0', width:'100%', height:'100%' });
    f.style.position = 'relative';
    f.appendChild(iframe);
    f.dataset.mounted = '1';

    // Wait for load OR timeout, then small delay
    await new Promise((resolve) => {
      let settled = false;
      const t = setTimeout(() => { if (!settled) { settled = true; resolve(); } }, loadTimeoutMs);
      iframe.addEventListener('load', () => {
        if (!settled) { clearTimeout(t); settled = true; }
        resolve();
      }, { once: true });
    });

    await new Promise(r => setTimeout(r, interMountDelayMs));
  }

  // Final sweep after 12s: if anything still missed, attach eagerly
  setTimeout(() => {
    const left = Array.from(document.querySelectorAll('.frame')).filter(f => f.dataset.mounted !== '1');
    left.forEach(f => {
      const el = document.createElement('iframe');
      el.src = f.dataset.embed;
      el.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
      Object.assign(el.style, { border:'0', position:'absolute', inset:'0', width:'100%', height:'100%' });
      f.style.position = 'relative';
      f.appendChild(el);
      f.dataset.mounted = '1';
    });
  }, 12000);
}

Then, at the point where you choose the loader:
if (isSmall) {
  mobileSequentialLoadStrict();
} else {
  // keep your existing desktop loader call here, unchanged
  desktopHeartbeatLoad();
}

4) Save and run the EXTERNAL preview on an iPhone/Android device (not the embedded panel).

Verify on phone:
- The first two clips show up quickly without scrolling.
- Additional clips continue to appear one-by-one even if you do not scroll.
- No “Sorry, privacy…” screens; if you see one, report the exact hostname so I can whitelist it in Vimeo settings.

Reply only with:
"STEP DONE — iOS reliability pass applied and verified"